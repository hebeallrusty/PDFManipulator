#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.9.5 on Fri May 22 19:30:43 2020
#

# Drag and drop code adapted from https://wiki.wxpython.org/Create%20a%20drop%20target%20(Phoenix)

import wx
from PDFManipulator import *
import requests
from Icon import *
import webbrowser
import subprocess

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

PROGRAM_VERSION = version()
PIKEPDF_VERSION = pikepdfversion()
FILE_WILDCARD = "PDF Files (*.pdf)|*.pdf;*.PDF;*Pdf;*PDf;*pDf;*pdF"

ENCRYPTION_STRENGTH = {0:6,1:4,2:0} # mapped to pikepdf levels
REPO_URL = 'https://github.com/hebeallrusty/PDFManipulator/tree/master/dist'

#DND
wxEVT_SPLITFILE_DROPPED = wx.NewEventType()
EVT_SPLITFILE_DROPPED = wx.PyEventBinder(wxEVT_SPLITFILE_DROPPED, 1)
wxEVT_ENCRYPTFILE_DROPPED = wx.NewEventType()
EVT_ENCRYPTFILE_DROPPED = wx.PyEventBinder(wxEVT_ENCRYPTFILE_DROPPED,1)
wxEVT_MULTIFILES_DROPPED = wx.NewEventType()
EVT_MULTIFILES_DROPPED = wx.PyEventBinder(wxEVT_MULTIFILES_DROPPED, 1)
wxEVT_SUBSINPUTFILE_DROPPED = wx.NewEventType()
EVT_SUBSINPUTFILE_DROPPED = wx.PyEventBinder(wxEVT_SUBSINPUTFILE_DROPPED, 1)
wxEVT_SUBSSUBFILE_DROPPED = wx.NewEventType()
EVT_SUBSSUBFILE_DROPPED = wx.PyEventBinder(wxEVT_SUBSSUBFILE_DROPPED, 1)
wxEVT_ROTATEFILE_DROPPED = wx.NewEventType()
EVT_ROTATEFILE_DROPPED = wx.PyEventBinder(wxEVT_ROTATEFILE_DROPPED, 1)

class FileDropEvent(wx.PyCommandEvent):
    def __init__(self, evtType):
        print(f'FileDropEvent; Event: {evtType}')
        wx.PyCommandEvent.__init__(self, evtType)
        self._items = []
        
    def SetSingleItem(self, item):
    	#print(f'self:{self}')
    	print(f'SetSingleItem:{item}')
    	# check if we have a file with a .pdf file ext
    	if item.lower()[-4:] == ".pdf":
    		pdfitem = item
    	else:
    		print(f'Not a pdf:{item}')
    		return
    	#self._items = [item]
    	self._items = [pdfitem]
        
    def GetSingleItem(self):
        print(f'GetSingleItem')
        if not self._items:
        	return ''
        return self._items[0]
        
    def AddItem(self, item):
        print(f'AddItem:{item}')
        self._items.append(item)
        
    def AddItems(self, items):
        print(f'AddItemS:{items}')
        # need to sanity check that we are not adding items willy nilly and that they are have pdf as file ext.
        
        # create a new sanitised list
        pdfitems = []
        
        # cycle through the items in the list
        for i in items:
        	print(f'item:{i}')
        	# if the item doesn't have the last 4 chars as .pdf then reject it otherwise add it to the sanitised list
        	if i.lower()[-4:] == ".pdf":
        		pdfitems.append(i)
        	else:
        		print(f'Not a pdf:{i}')
        		continue
        #self._items += items
        # substitute the sanitised list for the one that was given
        self._items += pdfitems
        
    def GetItems(self):
        print(f'GetItems')
        return self._items
        
class SplitFileDropTarget(wx.FileDropTarget):
    def __init__(self, dstHandler):
    	print(f'SplitFileDropTarget init;')
    	
    	wx.FileDropTarget.__init__(self)
    	self._target = dstHandler

    	
    def OnDropFiles(self, x, y, filenames):
    	print(f'InputFileDropTarget/OnDropFiles')

    	# As we can only accept one file at a time
    	# We take only the first element of the provided list
    	# And tell the destination handler that a new file has been dropped
    	evt = FileDropEvent(wxEVT_SPLITFILE_DROPPED)
    	evt.SetSingleItem(filenames[0])
    	self._target.GetEventHandler().AddPendingEvent(evt)
    	return True
        
class EncryptFileDropTarget(wx.FileDropTarget):
    def __init__(self, dstHandler):
    	print(f'SplitFileDropTarget init;')
    	
    	wx.FileDropTarget.__init__(self)
    	self._target = dstHandler

    	
    def OnDropFiles(self, x, y, filenames):
    	print(f'EncryptFileDropTarget/OnDropFiles')

    	# As we can only accept one file at a time
    	# We take only the first element of the provided list
    	# And tell the destination handler that a new file has been dropped
    	evt = FileDropEvent(wxEVT_ENCRYPTFILE_DROPPED)
    	evt.SetSingleItem(filenames[0])
    	self._target.GetEventHandler().AddPendingEvent(evt)
    	return True
    	
class SubsInputFileDropTarget(wx.FileDropTarget):
    def __init__(self, dstHandler):
    	print(f'SubsInputFileDropTarget init;')
    	
    	wx.FileDropTarget.__init__(self)
    	self._target = dstHandler

    	
    def OnDropFiles(self, x, y, filenames):
    	print(f'SubsInputFileDropTarget/OnDropFiles')

    	# As we can only accept one file at a time
    	# We take only the first element of the provided list
    	# And tell the destination handler that a new file has been dropped
    	evt = FileDropEvent(wxEVT_SUBSINPUTFILE_DROPPED)
    	evt.SetSingleItem(filenames[0])
    	self._target.GetEventHandler().AddPendingEvent(evt)
    	return True
    	
class SubsSubFileDropTarget(wx.FileDropTarget):
    def __init__(self, dstHandler):
    	print(f'SubsSubFileDropTarget init;')
    	
    	wx.FileDropTarget.__init__(self)
    	self._target = dstHandler

    	
    def OnDropFiles(self, x, y, filenames):
    	print(f'SubsSubFileDropTarget/OnDropFiles')

    	# As we can only accept one file at a time
    	# We take only the first element of the provided list
    	# And tell the destination handler that a new file has been dropped
    	evt = FileDropEvent(wxEVT_SUBSSUBFILE_DROPPED)
    	evt.SetSingleItem(filenames[0])
    	self._target.GetEventHandler().AddPendingEvent(evt)
    	return True

class RotateFileDropTarget(wx.FileDropTarget):
    def __init__(self, dstHandler):
    	print(f'RotateFileDropTarget init;')
    	
    	wx.FileDropTarget.__init__(self)
    	self._target = dstHandler

    	
    def OnDropFiles(self, x, y, filenames):
    	print(f'RotateFileDropTarget/OnDropFiles')

    	# As we can only accept one file at a time
    	# We take only the first element of the provided list
    	# And tell the destination handler that a new file has been dropped
    	evt = FileDropEvent(wxEVT_ROTATEFILE_DROPPED)
    	evt.SetSingleItem(filenames[0])
    	self._target.GetEventHandler().AddPendingEvent(evt)
    	return True
        
class MultiFilesDropTarget(wx.FileDropTarget):
    def __init__(self, dstHandler):
        print(f'MultiFilesDropTarget')
        wx.FileDropTarget.__init__(self)
        self._target = dstHandler
        
    def OnDropFiles(self, x, y, filenames):
        print(f'MultiFilesDropTarget/OnDropFiles')
        # We can accept all the given files
        # And tell the destination handler that a new file has been dropped
        evt = FileDropEvent(wxEVT_MULTIFILES_DROPPED)
        evt.AddItems(filenames)
        self._target.GetEventHandler().AddPendingEvent(evt)
        return True


class Frame_PDFManipulator(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: Frame_PDFManipulator.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((600, 365))
        # add icon
        # make an icon bundle
        icons = wx.IconBundle()
        icons.AddIcon(Icon256.GetIcon())
        icons.AddIcon(Icon192.GetIcon())
        icons.AddIcon(Icon128.GetIcon())
        icons.AddIcon(Icon96.GetIcon())
        icons.AddIcon(Icon64.GetIcon())
        icons.AddIcon(Icon48.GetIcon())
        icons.AddIcon(Icon40.GetIcon())
        icons.AddIcon(Icon32.GetIcon())
        icons.AddIcon(Icon24.GetIcon())
        icons.AddIcon(Icon16.GetIcon())
        self.SetIcons(icons)
        
        
        # Menu Bar
        self.Menu = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "&About", "")
        self.Bind(wx.EVT_MENU, self.Menu_About, id=item.GetId())
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "&Check for Update", "")
        # added in binding as not done in wxglade
        self.Bind(wx.EVT_MENU, self.Menu_Check_for_Update, id=item.GetId())
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "&Quit", "")
        self.Bind(wx.EVT_MENU, self.Menu_Quit, id=item.GetId())
        self.Menu.Append(wxglade_tmp_menu, "&Menu")
        self.SetMenuBar(self.Menu)
        # Menu Bar end
        self.Statusbar = self.CreateStatusBar(3, wx.STB_ELLIPSIZE_END | wx.STB_SIZEGRIP)
        self.Panel_PDFManipulator = wx.Panel(self, wx.ID_ANY)
        self.Notebook_Panel = wx.Notebook(self.Panel_PDFManipulator, wx.ID_ANY)
        self.Notebook_Split = wx.Panel(self.Notebook_Panel, wx.ID_ANY)
        
        self.Text_Split_InputFile = wx.TextCtrl(self.Notebook_Split, wx.ID_ANY, "", style=wx.TE_AUTO_URL | wx.TE_READONLY)
        self.Button_Split_InputFile = wx.Button(self.Notebook_Split, wx.ID_ANY, "...")
        self.Text_Split_StartPage = wx.TextCtrl(self.Notebook_Split, wx.ID_ANY, "")
        self.Radiobox_Split_OutputOptions = wx.RadioBox(self.Notebook_Split, wx.ID_ANY, "Output Option", choices=["Single file containing all pages", "Multiple files containing one page each"], majorDimension=1, style=wx.RA_SPECIFY_COLS)
        self.Notebook_Join = wx.Panel(self.Notebook_Panel, wx.ID_ANY)
        self.Button_Join_SelectFile = wx.Button(self.Notebook_Join, wx.ID_ANY, "Select File(s)")
        self.Button_Join_SelectFolder = wx.Button(self.Notebook_Join, wx.ID_ANY, "Select Folder")
        self.Listbox_Join_Files = wx.ListBox(self.Notebook_Join, wx.ID_ANY, choices=[], style= wx.LB_HSCROLL | wx.LB_NEEDED_SB)

        self.Button_Join_Up = wx.Button(self.Notebook_Join, wx.ID_ANY, u"↑")
        self.Button_Join_Down = wx.Button(self.Notebook_Join, wx.ID_ANY, u"↓")
        self.Button_Join_Remove = wx.Button(self.Notebook_Join, wx.ID_ANY, "Remove")
        self.Button_Join_Clear = wx.Button(self.Notebook_Join, wx.ID_ANY, "Clear All")
        self.Notebook_Encrypt = wx.Panel(self.Notebook_Panel, wx.ID_ANY)
        self.Text_Encrypt_InputFile = wx.TextCtrl(self.Notebook_Encrypt, wx.ID_ANY, "", style=wx.TE_AUTO_URL | wx.TE_READONLY)
        self.Button_Encrypt_InputFile = wx.Button(self.Notebook_Encrypt, wx.ID_ANY, "...")
        self.Radiobox_Encrypt_Options = wx.RadioBox(self.Notebook_Encrypt, wx.ID_ANY, "Encryption Options", choices=["Strongest (AES-256)", "Strong (AES-128)", "Remove Encryption"], majorDimension=3, style=wx.RA_SPECIFY_ROWS)
        self.Notebook_Subsitute = wx.Panel(self.Notebook_Panel, wx.ID_ANY)
        self.Text_Substitute_InputFile = wx.TextCtrl(self.Notebook_Subsitute, wx.ID_ANY, "", style=wx.TE_AUTO_URL | wx.TE_READONLY)
        self.Button_Substitute_InputFile = wx.Button(self.Notebook_Subsitute, wx.ID_ANY, "...")
        self.Text_Substitute_SubstituteFile = wx.TextCtrl(self.Notebook_Subsitute, wx.ID_ANY, "", style=wx.TE_AUTO_URL | wx.TE_READONLY)
        self.Button_Substitue_SubstituteFile = wx.Button(self.Notebook_Subsitute, wx.ID_ANY, "...")
        self.Text_Substitute_Pages = wx.TextCtrl(self.Notebook_Subsitute, wx.ID_ANY, "")
        self.Notebook_RotatePages = wx.Panel(self.Notebook_Panel, wx.ID_ANY)
        self.Text_Rotate_InputFile = wx.TextCtrl(self.Notebook_RotatePages, wx.ID_ANY, "", style=wx.TE_AUTO_URL | wx.TE_READONLY)
        self.Button_Rotate_InputFile = wx.Button(self.Notebook_RotatePages, wx.ID_ANY, "...")
        self.Text_Rotate_Pages = wx.TextCtrl(self.Notebook_RotatePages, wx.ID_ANY, "")
        self.Radiobox_Rotate_Rotation = wx.RadioBox(self.Notebook_RotatePages, wx.ID_ANY, "Rotation:", choices=["90 Deg (1/4 Turn)", "180 Deg (1/2 Turn)", "270 Deg (3/4 Turn)"], majorDimension=3, style=wx.RA_SPECIFY_ROWS)
        self.Radiobox_Rotation_Direction = wx.RadioBox(self.Notebook_RotatePages, wx.ID_ANY, "Direction", choices=["Clockwise (Right)", "Anti-Clockwise (Left)"], majorDimension=2, style=wx.RA_SPECIFY_ROWS)
        self.Button_Panel_Go = wx.Button(self.Panel_PDFManipulator, wx.ID_ANY, "Go")
        # Added as wxglade does not do it - allows text to be dynamic
        self.Label_Split_Info = wx.StaticText(self.Notebook_Split, wx.ID_ANY, "")
        
        #DND drop target
        dt = SplitFileDropTarget(self)
        self.Text_Split_InputFile.SetDropTarget(dt)
        
        dt = EncryptFileDropTarget(self)
        self.Text_Encrypt_InputFile.SetDropTarget(dt)
        
        dt = SubsInputFileDropTarget(self)
        self.Text_Substitute_InputFile.SetDropTarget(dt)
                
        dt = SubsSubFileDropTarget(self)
        self.Text_Substitute_SubstituteFile.SetDropTarget(dt)
                
        dt = RotateFileDropTarget(self)
        self.Text_Rotate_InputFile.SetDropTarget(dt)
                
        dt = MultiFilesDropTarget(self)
        self.Listbox_Join_Files.SetDropTarget(dt)
        

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.Event_Button_Split_InputFile, self.Button_Split_InputFile)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Join_SelectFile, self.Button_Join_SelectFile)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Join_SelectFolder, self.Button_Join_SelectFolder)
        self.Bind(wx.EVT_LISTBOX, self.Event_Listbox_Join_Files, self.Listbox_Join_Files)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Join_Up, self.Button_Join_Up)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Join_Down, self.Button_Join_Down)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Join_Remove, self.Button_Join_Remove)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Join_Clear, self.Button_Join_Clear)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Encrypt_InputFile, self.Button_Encrypt_InputFile)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Substitute_InputFile, self.Button_Substitute_InputFile)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Substitute_Substitute, self.Button_Substitue_SubstituteFile)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Rotate_InputFile, self.Button_Rotate_InputFile)
        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.Event_Notebook_Page_Changed, self.Notebook_Panel)
        self.Bind(wx.EVT_BUTTON, self.Event_Button_Panel_Go, self.Button_Panel_Go)
        
        #DND
        self.Bind(EVT_SPLITFILE_DROPPED, self.Event_Split_FileDropped)
        self.Bind(EVT_ENCRYPTFILE_DROPPED, self.Event_Encrypt_FileDropped)
        self.Bind(EVT_SUBSINPUTFILE_DROPPED, self.Event_Substitute_InputFileDropped)
        self.Bind(EVT_SUBSSUBFILE_DROPPED, self.Event_Substitute_SubFileDropped)
        self.Bind(EVT_ROTATEFILE_DROPPED, self.Event_RotateFileDropped)
        self.Bind(EVT_MULTIFILES_DROPPED, self._onMultiFilesDropped)
        
        
        
        # end wxGlade
        
    #DND
    def Event_Split_FileDropped(self, event):
    	print("SPLIT DROP")
    	#print(dir(event))
    	#print(event.GetEventObject)
    	#print(dir(event))
    	self.Label_Split_Info.SetLabel(f'')
    	self.Text_Split_InputFile.ChangeValue(event.GetSingleItem())
    	# check if the input file control is blank, and if not then advise how many pages there are in the pdf
    	pdf = self.Text_Split_InputFile.GetValue()
    	print(f'Dropped file rejected?: {pdf==""}')
    	if pdf != "" :
    		pages = get_pages(pdf)
    		try:
    			int(pages)
    		except:
    			dialog = wx.MessageDialog(self,pages, caption = "Error", style = wx.OK | wx.ICON_ERROR)
    			dialog.ShowModal()
    			return
    		self.Label_Split_Info.SetLabel(f'There are {pages} pages in this PDF')
	
    	
    def Event_Encrypt_FileDropped(self, event):
    	print("ENCRYPT DROP")
    	self.Text_Encrypt_InputFile.ChangeValue(event.GetSingleItem())   
    
    def Event_Substitute_InputFileDropped(self,event):
    	print("SUBS INPUT DROP")
    	self.Text_Substitute_InputFile.ChangeValue(event.GetSingleItem())
    
    def Event_Substitute_SubFileDropped(self,event):
    	print("SUBS SUB DROP")
    	self.Text_Substitute_SubstituteFile.ChangeValue(event.GetSingleItem())

    def Event_RotateFileDropped(self,event):
    	print("Rotate DROP")
    	self.Text_Rotate_InputFile.ChangeValue(event.GetSingleItem())
    	
    def _onMultiFilesDropped(self, evt):
        self.Listbox_Join_Files.Append(evt.GetItems())
        self.Listbox_Join_Files.EnsureVisible(self.Listbox_Join_Files.GetCount()-1)


    def __set_properties(self):
        # begin wxGlade: Frame_PDFManipulator.__set_properties
        self.SetTitle("PDFManipulator")
        self.Statusbar.SetStatusWidths([-1, -2,-1])

        # statusbar fields
        Statusbar_fields = ["Version:", "",""]
        for i in range(len(Statusbar_fields)):
            self.Statusbar.SetStatusText(Statusbar_fields[i], i)
        self.Text_Split_StartPage.SetToolTip("Enter 1-4 for pages 1 to 4 inclusive, or enter a single page number such as 7 for just that page")
        self.Radiobox_Split_OutputOptions.SetSelection(0)
        self.Radiobox_Encrypt_Options.SetSelection(0)
        self.Radiobox_Rotate_Rotation.SetSelection(0)
        self.Radiobox_Rotation_Direction.SetSelection(0)
        # set status bar text
        self.Statusbar.SetStatusText(f'Version: {PROGRAM_VERSION}',0)
        self.Statusbar.SetStatusText(f'Checking for Update...',1)
        ServerVersion = CheckUpdate()
        if ServerVersion == False:
        	self.Statusbar.SetStatusText(f'',1)
        	pass
        else:
        	self.Statusbar.SetStatusText(f'',1)
        	# check if the update version is greater than set status bar text
        	if PROGRAM_VERSION < ServerVersion:
        		self.Statusbar.SetStatusText(f'New Version Available: {ServerVersion}',1)
        
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: Frame_PDFManipulator.__do_layout
        Sizer_Application = wx.BoxSizer(wx.VERTICAL)
        Sizer_Panel = wx.BoxSizer(wx.VERTICAL)
        Sizer_Panel_Go = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Rotate = wx.BoxSizer(wx.VERTICAL)
        Sizer_Rotate_Direction = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Rotate_Pages = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Rotate_InputFile = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Substitute = wx.BoxSizer(wx.VERTICAL)
        Sizer_Substitute_Pages = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Substitute_SubstituteFile = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Substitute_InputFile = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Encrypt = wx.BoxSizer(wx.VERTICAL)
        Sizer_Encrypt_Options = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Encrypt_InputFile = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Join = wx.BoxSizer(wx.VERTICAL)
        Sizer_Join_ArrangeFiles = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Join_Listbox_Controls = wx.BoxSizer(wx.VERTICAL)
        Sizer_Join_SelectFiles = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Split = wx.BoxSizer(wx.VERTICAL)
        Sizer_Split_OutputOptions = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Split_Pages = wx.BoxSizer(wx.HORIZONTAL)
        Sizer_Split_InputFile = wx.BoxSizer(wx.HORIZONTAL)
        Label_Split_InputFile = wx.StaticText(self.Notebook_Split, wx.ID_ANY, "Select File:")
        Sizer_Split_InputFile.Add(Label_Split_InputFile, 0, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        Sizer_Split_InputFile.Add(self.Text_Split_InputFile, 10, wx.ALIGN_CENTER | wx.FIXED_MINSIZE, 0)
        Sizer_Split_InputFile.Add(self.Button_Split_InputFile, 0, wx.ALIGN_CENTER, 0)
        Sizer_Split.Add(Sizer_Split_InputFile, 0, wx.EXPAND | wx.TOP, 6)
        Label_Split_StartPage = wx.StaticText(self.Notebook_Split, wx.ID_ANY, "Pages:")
        Sizer_Split_Pages.Add(Label_Split_StartPage, 0, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        # removed vertical and horizontal from center
        Sizer_Split_Pages.Add(self.Text_Split_StartPage, 0, wx.ALIGN_CENTER | wx.LEFT, 28)
        Label_Split_EndPage = wx.StaticText(self.Notebook_Split, wx.ID_ANY, "e.g. 1-4 or 7", style=wx.ALIGN_CENTER)
        Sizer_Split_Pages.Add(Label_Split_EndPage, 0, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        # Remove this as allows control to be dynamic
        # Label_Split_Info = wx.StaticText(self.Notebook_Split, wx.ID_ANY, "There are x number of pages in this PDF")
        Sizer_Split_Pages.Add(self.Label_Split_Info, 0, wx.ALIGN_CENTER | wx.LEFT, 5)
        Sizer_Split.Add(Sizer_Split_Pages, 0, wx.EXPAND | wx.TOP, 10)
        Sizer_Split_OutputOptions.Add(self.Radiobox_Split_OutputOptions, 2, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        Sizer_Split.Add(Sizer_Split_OutputOptions, 0, wx.EXPAND | wx.TOP, 10)
        self.Notebook_Split.SetSizer(Sizer_Split)
        Label_Join_Add = wx.StaticText(self.Notebook_Join, wx.ID_ANY, "Add:")
        Sizer_Join_SelectFiles.Add(Label_Join_Add, 1, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        Sizer_Join_SelectFiles.Add(self.Button_Join_SelectFile, 2, wx.ALIGN_CENTER, 0)
        Sizer_Join_SelectFiles.Add(self.Button_Join_SelectFolder, 2, wx.ALIGN_CENTER, 0)
        Sizer_Join.Add(Sizer_Join_SelectFiles, 0, wx.EXPAND | wx.TOP, 5)
        #DND
        
        Sizer_Join_ArrangeFiles.Add(self.Listbox_Join_Files, 10, wx.EXPAND, 5)
        Sizer_Join_Listbox_Controls.Add(self.Button_Join_Up, 1, 0, 0)
        Sizer_Join_Listbox_Controls.Add(self.Button_Join_Down, 1, 0, 0)
        Sizer_Join_Listbox_Controls.Add(self.Button_Join_Remove, 1, 0, 0)
        Sizer_Join_Listbox_Controls.Add(self.Button_Join_Clear, 1, 0, 0)
        Sizer_Join_ArrangeFiles.Add(Sizer_Join_Listbox_Controls, 1, wx.EXPAND, 0)
        Sizer_Join.Add(Sizer_Join_ArrangeFiles, 0, wx.EXPAND | wx.TOP, 9)
        self.Notebook_Join.SetSizer(Sizer_Join)
        Label_Encrypt_InputFile = wx.StaticText(self.Notebook_Encrypt, wx.ID_ANY, "Select File:")
        Sizer_Encrypt_InputFile.Add(Label_Encrypt_InputFile, 0, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        Sizer_Encrypt_InputFile.Add(self.Text_Encrypt_InputFile, 10, wx.ALIGN_CENTER | wx.FIXED_MINSIZE, 0)
        Sizer_Encrypt_InputFile.Add(self.Button_Encrypt_InputFile, 0, wx.ALIGN_CENTER, 0)
        Sizer_Encrypt.Add(Sizer_Encrypt_InputFile, 0, wx.EXPAND | wx.TOP, 5)
        Sizer_Encrypt_Options.Add(self.Radiobox_Encrypt_Options, 1, wx.EXPAND | wx.LEFT, 5)
        Sizer_Encrypt.Add(Sizer_Encrypt_Options, 0, wx.EXPAND | wx.TOP, 10)
        self.Notebook_Encrypt.SetSizer(Sizer_Encrypt)
        Label_Substitute_InputFile = wx.StaticText(self.Notebook_Subsitute, wx.ID_ANY, "Select File:")
        Sizer_Substitute_InputFile.Add(Label_Substitute_InputFile, 0, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        Sizer_Substitute_InputFile.Add(self.Text_Substitute_InputFile, 10, wx.ALIGN_CENTER | wx.FIXED_MINSIZE, 0)
        Sizer_Substitute_InputFile.Add(self.Button_Substitute_InputFile, 0, wx.ALIGN_CENTER, 0)
        Sizer_Substitute.Add(Sizer_Substitute_InputFile, 0, wx.EXPAND | wx.TOP, 5)
        Label_Substitute_SubstituteFile = wx.StaticText(self.Notebook_Subsitute, wx.ID_ANY, "Substitute:")
        Sizer_Substitute_SubstituteFile.Add(Label_Substitute_SubstituteFile, 0, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        Sizer_Substitute_SubstituteFile.Add(self.Text_Substitute_SubstituteFile, 10, wx.ALIGN_CENTER | wx.FIXED_MINSIZE, 0)
        Sizer_Substitute_SubstituteFile.Add(self.Button_Substitue_SubstituteFile, 0, wx.ALIGN_CENTER, 0)
        Sizer_Substitute.Add(Sizer_Substitute_SubstituteFile, 0, wx.EXPAND | wx.TOP, 10)
        Label_Substitute_Page = wx.StaticText(self.Notebook_Subsitute, wx.ID_ANY, "Start Page:")
        Sizer_Substitute_Pages.Add(Label_Substitute_Page, 0, wx.ALIGN_CENTER | wx.LEFT, 5)
        Sizer_Substitute_Pages.Add(self.Text_Substitute_Pages, 0, wx.ALIGN_CENTER | wx.LEFT, 5)
        Sizer_Substitute_Pages.Add((20, 20), 4, wx.ALIGN_CENTER | wx.ALL, 4)
        Sizer_Substitute.Add(Sizer_Substitute_Pages, 0, wx.EXPAND | wx.TOP, 10)
        self.Notebook_Subsitute.SetSizer(Sizer_Substitute)
        Label_Rotate_InputFile = wx.StaticText(self.Notebook_RotatePages, wx.ID_ANY, "Select File:")
        Sizer_Rotate_InputFile.Add(Label_Rotate_InputFile, 0, wx.ALIGN_CENTER | wx.LEFT | wx.RIGHT, 5)
        Sizer_Rotate_InputFile.Add(self.Text_Rotate_InputFile, 10, wx.ALIGN_CENTER | wx.FIXED_MINSIZE, 0)
        Sizer_Rotate_InputFile.Add(self.Button_Rotate_InputFile, 0, wx.ALIGN_CENTER, 0)
        Sizer_Rotate.Add(Sizer_Rotate_InputFile, 0, wx.EXPAND | wx.TOP, 5)
        Label_Rotate_Page = wx.StaticText(self.Notebook_RotatePages, wx.ID_ANY, "Pages:")
        Sizer_Rotate_Pages.Add(Label_Rotate_Page, 0, wx.ALIGN_CENTER | wx.LEFT, 5)
        Sizer_Rotate_Pages.Add(self.Text_Rotate_Pages, 1, wx.ALIGN_CENTER | wx.LEFT, 33)
        Label_Rotate_Example = wx.StaticText(self.Notebook_RotatePages, wx.ID_ANY, "e.g. 1-3, 5, 8")
        Sizer_Rotate_Pages.Add(Label_Rotate_Example, 1, wx.ALIGN_CENTER | wx.LEFT, 5)
        Sizer_Rotate.Add(Sizer_Rotate_Pages, 0, wx.EXPAND | wx.TOP, 10)
        Sizer_Rotate_Direction.Add(self.Radiobox_Rotate_Rotation, 1, wx.LEFT, 5)
        Sizer_Rotate_Direction.Add(self.Radiobox_Rotation_Direction, 1, wx.EXPAND | wx.LEFT, 5)
        Sizer_Rotate.Add(Sizer_Rotate_Direction, 0, wx.EXPAND | wx.TOP, 10)
        self.Notebook_RotatePages.SetSizer(Sizer_Rotate)
        self.Notebook_Panel.AddPage(self.Notebook_Split, "Split")
        self.Notebook_Panel.AddPage(self.Notebook_Join, "Join")
        self.Notebook_Panel.AddPage(self.Notebook_Encrypt, "Encrypt")
        self.Notebook_Panel.AddPage(self.Notebook_Subsitute, "Substitute Pages")
        self.Notebook_Panel.AddPage(self.Notebook_RotatePages, "Rotate Pages")
        Sizer_Panel.Add(self.Notebook_Panel, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 6)
        Sizer_Panel_Go.Add((20, 25), 1, wx.LEFT, 5)
        Sizer_Panel_Go.Add(self.Button_Panel_Go, 0, 0, 0)
        Sizer_Panel.Add(Sizer_Panel_Go, 0, wx.BOTTOM | wx.EXPAND | wx.RIGHT | wx.TOP, 5)
        self.Panel_PDFManipulator.SetSizer(Sizer_Panel)
        Sizer_Application.Add(self.Panel_PDFManipulator, 1, wx.EXPAND, 0)
        self.SetSizer(Sizer_Application)
        self.Layout()
        # end wxGlade

    def Menu_About(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        dialog = wx.MessageDialog(self,f'PDFManipulator Version: {PROGRAM_VERSION} \n\nCreated By: Ashley Butler \nLicenced under GNU General Public License v3.0 \n\nUtilises the pikepdf library (version {PIKEPDF_VERSION}) licenced under Mozilla Public License 2.0',caption = "About...",style = wx.OK | wx.ICON_INFORMATION)
        dialog.ShowModal()
        event.Skip()
        
    def Menu_Check_for_Update(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        self.Statusbar.SetStatusText(f'Checking for Update...',1)
        ServerVersion = CheckUpdate()
        print(ServerVersion)
        if int(PROGRAM_VERSION) < ServerVersion:
        	dialog = wx.MessageDialog(self,f'New Version available: {ServerVersion} \nCurrent Version: {PROGRAM_VERSION} \n\nWould you like to visit the webpage to download it?',caption = "Check for Update",style = wx.YES_NO |wx.CANCEL | wx.ICON_INFORMATION)
        	# store result to test what user clicked
        	result =  dialog.ShowModal()
        	if result == wx.ID_YES:
        		# user would like to download the update - so open the browser
        		# TODO tidy up the repository of files so that the user can find them - maybe select folder based on OS to make it simpler? Might be worth writing an updater / installer to take care of the install
        		webbrowser.open(REPO_URL)
        			

        else:
        	self.Statusbar.SetStatusText(f'',1)
        	dialog = wx.MessageDialog(self,f'No newer version available',caption = "Check for Update",style = wx.OK | wx.ICON_INFORMATION)
        	dialog.ShowModal()
        event.Skip()

    def Menu_Quit(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        self.Destroy()
        event.Skip()

    def Event_Button_Split_InputFile(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # show file selection, then put file path and name into Text_Split_InputFile
        self.OpenFile(self.Text_Split_InputFile)
        
        event.Skip()

    def Event_Button_Join_SelectFile(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # show file selection, then put file path and name into Text_Split_InputFile
        self.OpenFiles(self.Listbox_Join_Files)		
        
        event.Skip()

    def Event_Button_Join_SelectFolder(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # show folder selection - additional processing requried to get the pdf files
        self.OpenFolder(self.Listbox_Join_Files)
        
        event.Skip()

    def Event_Listbox_Join_Files(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        print("Event handler 'Event_Listbox_Join_Files' not implemented!")
        event.Skip()

    def Event_Button_Join_Up(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        selecteditem = self.Listbox_Join_Files.GetSelection()
        # if we haven't selected anything (-1) or are on the first item in the list (0) then return
        if (self.Listbox_Join_Files.GetSelection() <= 0):
        	return
        # produce a list of all items in the listbox
        listboxitems = [self.Listbox_Join_Files.GetString(i) for i in range(0,self.Listbox_Join_Files.GetCount())]
        # Listbox needs clearing and starting again now that we have all the items
        self.Listbox_Join_Files.Clear()
        # insert new list items with the two items swaped over
        self.Listbox_Join_Files.InsertItems(swap_item(listboxitems,selecteditem,selecteditem - 1),0)
        # update the listbox
        self.Listbox_Join_Files.Update()
        # move the focus to the newly moved item
        self.Listbox_Join_Files.SetSelection(selecteditem - 1)
        #print(listboxitems)
        event.Skip()

    def Event_Button_Join_Down(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        selecteditem = self.Listbox_Join_Files.GetSelection()
        maxitem = self.Listbox_Join_Files.GetCount()
        #print(maxitem)
        # if we haven't selected anything (-1) or are on the last item in the list (maxitem - 1 due to 0 indexing) then return
        if (self.Listbox_Join_Files.GetSelection() == -1) or (self.Listbox_Join_Files.GetSelection() == maxitem - 1):
        	return
        # produce a list of all items in the listbox
        listboxitems = [self.Listbox_Join_Files.GetString(i) for i in range(0,maxitem)]
        # Listbox needs clearing and starting again now that we have all the items
        self.Listbox_Join_Files.Clear()
        # insert new list items with the two items swaped over
        self.Listbox_Join_Files.InsertItems(swap_item(listboxitems,selecteditem,selecteditem + 1),0)
        # update the listbox
        self.Listbox_Join_Files.Update()
        # move the focus to the newly moved item
        self.Listbox_Join_Files.SetSelection(selecteditem + 1)
        #print(listboxitems)
        event.Skip()

    def Event_Button_Join_Remove(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # if the listbox is empty or there is nothing selected - return
        maxitem = self.Listbox_Join_Files.GetCount()
        selecteditem = self.Listbox_Join_Files.GetSelection()
        print(f'selected {selecteditem}. max item {maxitem}')
        if (maxitem == 0) or (selecteditem == -1):
        	return
        # get all the items in the listbox
        listboxitems = [self.Listbox_Join_Files.GetString(i) for i in range(0,maxitem)]
        # clear listbox
        self.Listbox_Join_Files.Clear()
        del listboxitems[selecteditem]
        # delete the item that was selected and reinsert the list into the listbox
        # check that we are not trying to insert an empty list into the listbox
        if maxitem == 1:
        	return
        self.Listbox_Join_Files.InsertItems(listboxitems,0)
        self.Listbox_Join_Files.Update()
        
        # move focus to the item above

        if maxitem - 1 == 1:
        	self.Listbox_Join_Files.SetSelection(0)
        	return
        elif selecteditem + 1 == maxitem:
        	self.Listbox_Join_Files.SetSelection(selecteditem - 1)
        else:
        	self.Listbox_Join_Files.SetSelection(selecteditem)
        event.Skip()

    def Event_Button_Join_Clear(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
    	# Double check the user pressed the clear button
        dialog = wx.MessageDialog(self,f'Are you sure you want to clear the list?',caption = "Clear List?",style = wx.YES_NO | wx.ICON_QUESTION)
        # No was selected
        if dialog.ShowModal() == wx.ID_NO:
        	return
        else: # Yes was selected
        	self.Listbox_Join_Files.Clear()
        		
        event.Skip()

    def Event_Button_Encrypt_InputFile(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # show file selection, then put file path and name into Text_Split_InputFile
        self.OpenFile(self.Text_Encrypt_InputFile)

        event.Skip()

    def Event_Button_Substitute_InputFile(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
       	self.OpenFile(self.Text_Substitute_InputFile)
       	
        event.Skip()

    def Event_Button_Substitute_Substitute(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # show file selection, then put file path and name into Text_Split_InputFile
       	self.OpenFile(self.Text_Substitute_SubstituteFile)
       	
        event.Skip()


    def Event_Button_Rotate_InputFile(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # show file selection, then put file path and name into Text_Split_InputFile
       	self.OpenFile(self.Text_Rotate_InputFile)

        event.Skip()

    def Event_Notebook_Page_Changed(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        print("Event handler 'Event_Notebook_Page_Changed' not implemented!")
        event.Skip()

    def Event_Button_Panel_Go(self, event):  # wxGlade: Frame_PDFManipulator.<event_handler>
        # get which page currently has focus so that we can split execution into the relevant sections

        NotebookPage = self.Notebook_Panel.GetPageText(self.Notebook_Panel.GetSelection())
        #OutputFile = self.Text_Panel_SelectOutputFile.GetValue()

        if NotebookPage == "Split":
        	# pick up the values of each relevant section
        	InputFile = self.Text_Split_InputFile.GetValue()
        	# check if the input file is missing so halt
        	if InputFile == "":
        		dialog = wx.MessageDialog(self,f'Plese select a file to split',caption = "File Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	
        	# pick up the page numbers and then we need to test if it is sane
        	Pages = ConvertSimpleRange(self.Text_Split_StartPage.GetValue())
        	
        	if Pages == False:
        		dialog = wx.MessageDialog(self,f'Page numbers should be numeric. If it\'s a page range, then page numbers should be separated with a single hyphen (-) e.g. 1-5. Do not include a space',caption = "Page Number Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	
        	# find what the biggest page number is to ensure our range fits with the PDF file
        	trymaxpages = get_pages(InputFile)	
        	if trymaxpages[0] == False:
        		dialog = wx.MessageDialog(self,f'Unable to get number of pages from file. {trymaxpages[1]}',caption = "Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	else:
        		maxpages = trymaxpages[1]
        	
        	
        	# check page number boundaries don't exceed pdf boundaries
        	if (Pages[0] < 1) or (Pages[1] > maxpages) or (Pages[0] > maxpages) or (Pages[1] < 1) or (Pages[0] > Pages[1]):
        		dialog = wx.MessageDialog(self,f'Page number selection should be between 1 and {maxpages}',caption = "Page Selection Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	
	
			# get the splitting choice
			
        	OutputFileChoice = self.Radiobox_Split_OutputOptions.GetSelection()  
        	
        	# Now we can ask where the output is to be saved

        	OutputFile = self.SaveFile(False)
        	#print(OutputFile)
        	
        	# carry out the split operation
        	self.Statusbar.SetStatusText(f'Working...',2)
        	result = split(InputFile,OutputFile,Pages,dismantle = OutputFileChoice)
        	self.Statusbar.SetStatusText(f'',2)
        	
        	if result == True:
        		# let the user know that the process has completed
        		dialog = wx.MessageDialog(self,f'Operation has Completed',caption = "Complete",  style = wx.OK | wx.ICON_INFORMATION)
        		dialog.ShowModal()
        	else:
        		# there was an error and the result is the error message
        		dialog = wx.MessageDialog(self,result,caption = "Error", style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        	
        	#############################
        	#############################
        	#############################
        elif NotebookPage == 'Join':
        	maxitem = self.Listbox_Join_Files.GetCount()
        	if maxitem == 0:
        		return

        	# validation complete - get all the list items
        	listbox = [self.Listbox_Join_Files.GetString(i) for i in range(0,maxitem)]
        	# get a file location to save to
        	OutputFile = self.SaveFile()
        	
        	self.Statusbar.SetStatusText(f'Working...',2)
        	join(listbox,OutputFile)
        	self.Statusbar.SetStatusText(f'',2)
         	# let the user know that the process has completed
        	dialog = wx.MessageDialog(self,f'Operation has Completed',caption = "Complete",  style = wx.OK | wx.ICON_INFORMATION)
        	dialog.ShowModal()  
        	 
        	#############################
        	#############################
        	#############################        	   
        if NotebookPage == "Encrypt":
            # pick up the values of each relevant section
        	InputFile = self.Text_Encrypt_InputFile.GetValue()
			
			# a file is missing so halt
        	if InputFile == "":
        		dialog = wx.MessageDialog(self,f'Plese select a file to encrypt',caption = "File Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        		
        	EncryptionStrength = int(ENCRYPTION_STRENGTH[self.Radiobox_Encrypt_Options.GetSelection()])
        	
 
        	password = [] 
         	# check if we actually want to decrypt file      	
        	if EncryptionStrength != 0: # User wants to encrypt file

        		# get the user to enter the passwords into a dialog box
        		for i in range(0,2):
        			passwd = wx.PasswordEntryDialog(self, "Enter a Password:", f'Password dialog {i + 1}',"" ,style=wx.TextEntryDialogStyle)
        			ans = passwd.ShowModal()
        			if ans == wx.ID_OK:
        				password.append(passwd.GetValue())
        			else:
        				return
        			passwd.Destroy()	
        		#print(self.Text_Encrypt_Password1.GetValue())	
        		# check if the passwords match
        		if password[0] != password[1]:
        			dialog = wx.MessageDialog(self,f'Passwords don\'t match',caption = "Password Error",style = wx.OK | wx.ICON_ERROR)
        			dialog.ShowModal()
        			return
        	else: # user wants to decrypt file
        		# get the user to enter password
        		passwd = wx.PasswordEntryDialog(self, "Enter Unlock Password:", f'Password Unlock',"" ,style=wx.TextEntryDialogStyle)
        		ans = passwd.ShowModal()
        		if ans == wx.ID_OK:
        			print(passwd.GetValue())
        			# if password is false throw an error, if it's true, then add password to the list
        			if TestEncryption(InputFile,passwd.GetValue()) == True:

        				dialog = wx.MessageDialog(self,f'Incorrect Password',caption = "Unlock Error",style = wx.OK | wx.ICON_ERROR)
        				dialog.ShowModal()
        				return
        			else:
        				password.append(passwd.GetValue())
        		else:
        			return
        		passwd.Destroy()
        		    			
        	#print(EncryptionStrength==4)

        	# validation complete
        	
        	# get the output filename
        	OutputFile = self.SaveFile(False)
        	
        	if EncryptionStrength != 0: # encrypt:
        		self.Statusbar.SetStatusText(f'Working...',2)
        		encrypt(InputFile,OutputFile,password[0],EncryptionStrength)
        		self.Statusbar.SetStatusText(f'',2)
        	else:
        		self.Statusbar.SetStatusText(f'Working...',2)
        		RemoveEncryption(InputFile,OutputFile,password[0])
        		self.Statusbar.SetStatusText(f'',2)
			# let the user know that the process has completed
        	dialog = wx.MessageDialog(self,f'Operation has Completed',caption = "Complete",  style = wx.OK | wx.ICON_INFORMATION)
        	dialog.ShowModal()
        	
        	#############################
        	#############################
        	############################# 
        if NotebookPage == "Rotate Pages":
			#check that we have a file in the input box
        	InputFile = self.Text_Rotate_InputFile.GetValue()
			
        	# a file is missing so halt
        	if InputFile == "":	
        		dialog = wx.MessageDialog(self,f'Plese select a file to rotate pages within',caption = "File Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return    
        	# Get page Ranges
        	trymaxpages = get_pages(InputFile)
        	if trymaxpages == False:
        		dialog = wx.MessageDialog(self,f'Unable to get pages from file {trymaxpages[1]}',caption = "Error", style = wx.OK | wx.ICON_ERROR)
        		dialgon.ShowModal()
        		return 
        		
        	else:
        		maxpages = trymaxpages
        	
        	Pages = self.Text_Rotate_Pages.GetValue()
        	
        	# get the sane list of pages to rotate - if list is not sane (i.e isn't like 1-3,5,7,9-12 etc) then the function will return false
        	PageList = ConvertMixedRanges(Pages)
        	
        	PageErrorFlag = False
        	
        	if PageList == False: PageErrorFlag = True
        	
        	if PageErrorFlag == False:	
        		if (max(PageList) > maxpages) or (min(PageList) < 1):
        			PageErrorFlag = True
        	
        	# if the PageErrorFlag has tripped, then the pages are not sane	
        	if PageErrorFlag == True:
        		dialog = wx.MessageDialog(self,f'Desired pages must be in the range of 1 - {maxpages}',caption = "Page Range Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return

        	# get direction of rotation
        	
        	Direction = self.Radiobox_Rotation_Direction.GetSelection()
        	# 0 here is Clockwise; 1 is Anti-clockwise. pikepdf rotates clockwise so we need to adjust the rotation only if Direction = 1
        	#RotationDegrees = {0:90;1:180;2:270}
        	Rotation = (self.Radiobox_Rotate_Rotation.GetSelection() * 90) + 90 # since selection will just be a zero indexed number
        	#print(Rotation)
        	if Direction == 1: # then we need to go the other way, but return what the rotation is if it were done clockwise
        		Rotation = 360 - Rotation
        		
        	# get a filename to save to
        	OutputFile = self.SaveFile(False)
        	
        	
        	# Call our rotation function
        	self.Statusbar.SetStatusText(f'Working...',2)
        	RotatePages(InputFile,OutputFile,PageList,Rotation)
        	self.Statusbar.SetStatusText(f'',2)
        	dialog = wx.MessageDialog(self,f'Operation has Completed',caption = "Complete",  style = wx.OK | wx.ICON_INFORMATION)
        	dialog.ShowModal()        	
        	#print("Done")
        			
        	#############################
        	#############################
        	############################# 
        if NotebookPage == "Substitute Pages":

        	InputFile = self.Text_Substitute_InputFile.GetValue()
			
        	# a file is missing so halt
        	if InputFile == "":	
        		dialog = wx.MessageDialog(self,f'Plese select a file to that will have it\'s pages substituted',caption = "File Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return   
        	SubsFile = self.Text_Substitute_SubstituteFile.GetValue()
			
        	# a file is missing so halt
        	if SubsFile == "":	
        		dialog = wx.MessageDialog(self,f'Plese select a file containing substitution pages',caption = "File Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return  
        	
        	
        	# get the page number
        	
        	PageNo = self.Text_Substitute_Pages.GetValue()
        	print(PageNo)
        	
        	try:
        		PageNo = int(PageNo)
        	except:
        		dialog = wx.MessageDialog(self,f'Plese enter a valid starting page',caption = "Page Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	# find the number of pages in both docs
        	
        	trymaxpages = [get_pages(InputFile),get_pages(SubsFile)]
        	if (trymaxpages[0][0] == False) or (trymaxpages[1][0] == False):
        		dialog = wx.MessageDialog(self,f'Unable to get number of pages in file {trymaxpages[0][0]}:{trymaxpages[1][0]}',caption = "Error", style = wx.OK | wx.ICON_ERROR)
        		return
        	else:
        		maxpages = [trymaxpages[0][1],trymaxpages[1][1]]

        	#print(maxpages)
        	#print(PageNo + maxpages[1])
        	# Validate Page number
        	if (PageNo < 1):
        		dialog = wx.MessageDialog(self,f'Page Number must be 1 or greater',caption = "Page Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return

        	elif (PageNo > maxpages[0]):
        		dialog = wx.MessageDialog(self,f'Page number is greater than number of pages in the original file ({maxpages[0]})',caption = "Page Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	elif (maxpages[1] > maxpages[0]):
        		dialog = wx.MessageDialog(self,f'There are more pages in the Substitution file than in the Original File',caption = "Page Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	elif (PageNo - 1 + maxpages[1] > maxpages[0]): # need the -1 otherwise you can't do the last page in the file
        		dialog = wx.MessageDialog(self,f'Page number ({PageNo}) plus number of pages in substitution file ({maxpages[1]}) are greater than in the original file ({maxpages[0]})',caption = "Page Error",style = wx.OK | wx.ICON_ERROR)
        		dialog.ShowModal()
        		return
        	
        	
        	# get a filename to save to
        	OutputFile = self.SaveFile(False)
        	
        	# run script
        	self.Statusbar.SetStatusText(f'Working...',2)
        	emplace(InputFile,OutputFile,SubsFile,PageNo)
        	self.Statusbar.SetStatusText(f'',2)
        	dialog = wx.MessageDialog(self,f'Operation has Completed',caption = "Complete",  style = wx.OK | wx.ICON_INFORMATION)
        	dialog.ShowModal()        	
        	
        event.Skip()
#######################################################################
    
    def OpenFile(self,control):
    	with wx.FileDialog(self,"Open PDF File", wildcard = FILE_WILDCARD, style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_CHANGE_DIR) as fileDialog:
        	# if the cancel button was pressed - do nothing and return
        	if fileDialog.ShowModal() == wx.ID_CANCEL:
        		return
        	
        	# put the file path into the text control
        	pathname = fileDialog.GetPath()
        	control.SetValue(pathname)
        	
    def OpenFiles(self,control):
    	with wx.FileDialog(self,"Open PDF File", wildcard = FILE_WILDCARD, style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_CHANGE_DIR | wx.FD_MULTIPLE) as fileDialog:
        	# if the cancel button was pressed - do nothing and return
        	if fileDialog.ShowModal() == wx.ID_CANCEL:
        		return
        	# multiple files may have been selected so use GetPath*s* - return is a list of file names
        	pathnames = fileDialog.GetPaths()
        	
        # populate the list box. Ensure that items are added at the end of the list
    	control.InsertItems(pathnames,control.GetCount())
    
    def OpenFolder(self,control):
    	with wx.DirDialog(self,"Choose folder of PDF files",style = wx.DD_DEFAULT_STYLE | wx.DD_DIR_MUST_EXIST) as dirDialog:
        	# return if cancel button was pressed
        	if dirDialog.ShowModal() == wx.ID_CANCEL:
        		return
        	dirname = dirDialog.GetPath()
    	pathnames = files_in_folder(dirname)
    	# print(pathnames)
    	# return if there are no pdf's in the directory
    	if not pathnames:
    		return
    	# populate the list box - items to be added at the end
    	control.InsertItems(pathnames,control.GetCount())
    	
    def SaveFile(self,fileextrequired=True):
    	# get a filename to save to
    	with wx.FileDialog(self, "Save PDF File", wildcard = FILE_WILDCARD, style = wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
        	if fileDialog.ShowModal() == wx.ID_CANCEL:
        		return
        	# enter file name into output text box
        	pathname = fileDialog.GetPath()
        	
        #print(pathname.lower())
        # filename might not have .pdf in filename, so add it in if it's missing - PDF function adds ",pdf" automatically
    	if pathname.lower()[-4:] != ".pdf":
    		pathname = ''.join([pathname,".pdf"])
    	# return can be different depending if the extension is required or not	
    	if fileextrequired == True:
    		return pathname
    	else:
    		return pathname[:-4]
    	return pathname	
    	

# end of class Frame_PDFManipulator

class MyApp(wx.App):
    def OnInit(self):
        self.frame = Frame_PDFManipulator(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame)
        self.frame.Show()

        return True

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
